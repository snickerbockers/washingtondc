/*******************************************************************************
 *
 * Copyright 2019, 2020 snickerbockers
 * snickerbockers@washemu.org
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <errno.h>
#include <sys/stat.h>

#include "washdc/fifo.h"

#include "config_file.h"

#define CFG_NODE_KEY_LEN 256
#define CFG_NODE_VAL_LEN 256

struct cfg_node {
    struct fifo_node list_node;
    char key[CFG_NODE_KEY_LEN];
    char val[CFG_NODE_VAL_LEN];
};

enum cfg_parse_state {
    CFG_PARSE_PRE_KEY,
    CFG_PARSE_KEY,
    CFG_PARSE_PRE_VAL,
    CFG_PARSE_VAL,
    CFG_PARSE_POST_VAL,
    CFG_PARSE_ERROR
};

static struct cfg_state {
    enum cfg_parse_state state;
    unsigned key_len, val_len;
    char key[CFG_NODE_KEY_LEN];
    char val[CFG_NODE_VAL_LEN];
    unsigned line_count;
    struct fifo_head cfg_nodes;
    bool in_comment;
} cfg_state;

static void cfg_add_entry(void);
static void cfg_handle_newline(void);
static int cfg_parse_bool(char const *val, bool *outp);

void cfg_create_default_config(FILE *cfg_file) {
    static char const *cfg_default =
        ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
        ";;;;;;;;;;\n"
        ";;\n"
        ";; AUTOMATICALLY GENERATED BY WASHINGTONDC\n"
        ";;\n"
        ";; This is WashingtonDC's config file.  Config settings consist of a "
        "config\n"
        ";; name followed by its value on the same line\n"
        ";; the semicolon (;) character can be used to create single-line "
        "comments\n"
        ";;\n"
        ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
        ";;;;;;;;;;\n"
        "\n"
        "; set to true to save system memory to <cwd>/wawashdc_error_dump.bin\n"
        "; when the emulator raises an error (only useful for debugging \n"
        "; purposes)\n"
        "wash.dbg.dump_mem_on_error false\n"
        "\n"
        "; background color (use html hex syntax)\n"
        "ui.bgcolor #3d77c0\n"
        "\n"
        "; vsync\n"
        "; options are true (to enable) or false (to disable)\n"
        "win.vsync false\n"
        "\n"
        "; default external resolution.  this is the size of the window when\n"
        "; it is initially created, but you can also change it at runtime by\n"
        "; resizing the window.\n"
        "win.external-res.x 640\n"
        "win.external-res.y 480\n"
        "\n"
        "; Pick what kind of window you want.\n"
        "; available values are:\n"
        "; * windowed\n"
        "; * fullscreen\n"
        "win.window-mode windowed\n"
        "\n"
        "; how to filter the final image.  choices are:\n"
        ";     nearest - for nearest-neighbor sampling\n"
        ";     linear - for bilinear interpolation\n"
        "gfx.output.filter linear\n"
        "\n"
        "; Order-Independent Transparency algorithm.  choices are:\n"
        ";     disabled - no order-independent transparency\n"
        ";     per-group - groups of transparent polygons are sorted by depth\n"
        "; Ideally there would be a per-pixel mode, as well, but that hasn't\n"
        "; been implemented yet.  per-group is far from perfect but it does\n"
        "; seem to be a good enough approximation most of the time.\n"
        "gfx.rend.oit-mode per-group\n"
        "\n"
        "; set this to true to mute audio.  Set it to false to allow audio \n"
        "; to play\n"
        "audio.mute false\n"
        "\n"
        "; to \"unplug\" any of the below controllers, comment out or delete it\n"
        "wash.dc.port.0.0 dreamcast_controller\n"
        "wash.dc.port.1.0 dreamcast_controller\n"
        "wash.dc.port.2.0 dreamcast_controller\n"
        "wash.dc.port.3.0 dreamcast_controller\n"
        "\n"
        "; default execution speed\n"
        "; choices are\n"
        ";     full: run at 100% speed\n"
        ";     unlimited: run as fast as the host machine will allow\n"
        ";     pause: start the emulator paused\n"
        "exec.speed full\n"
        "\n"
        /*
         * TODO: find a way to explain the naming convention for control
         * bindings to end-users
         */
        "wash.ctrl.toggle-overlay kbd.f2\n"
        "wash.ctrl.toggle-filter kbd.f3\n"
        "wash.ctrl.toggle-wireframe kbd.f4\n"

        "wash.ctrl.resume-execution kbd.f5\n"
        "wash.ctrl.run-one-frame kbd.f6\n"
        "wash.ctrl.pause-execution kbd.f7\n"

        "wash.ctrl.toggle-mute kbd.f8\n"
        "wash.ctrl.toggle-fullscreen kbd.f11\n"
        "wash.ctrl.screenshot kbd.f12\n"

        "wash.ctrl.renderdoc-capture kbd.f10\n"

        "\n"
        "; this bind can be used to immediately terminate WashingtonDC\n"
        "; it's disabled by default to prevent users from pressing it by\n"
        "; mistake, but if you feel confident in your ability to never hit\n"
        "; the wrong key then feel free to use this bind.\n"
        "; wash.ctrl.exit kbd.f10\n"
        "\n"
        "dc.ctrl.p1.dpad-up     gp0.btn.up\n"
        "dc.ctrl.p1.dpad-left   gp0.btn.left\n"
        "dc.ctrl.p1.dpad-down   gp0.btn.down\n"
        "dc.ctrl.p1.dpad-right  gp0.btn.right\n"
        "dc.ctrl.p1.stick-left  gp0.axis.lhor-\n"
        "dc.ctrl.p1.stick-right gp0.axis.lhor+\n"
        "dc.ctrl.p1.stick-up    gp0.axis.lvert-\n"
        "dc.ctrl.p1.stick-down  gp0.axis.lvert+\n"
        "dc.ctrl.p1.trig-l      gp0.axis.l2\n"
        "dc.ctrl.p1.trig-r      gp0.axis.r2\n"
        "dc.ctrl.p1.btn-a       gp0.btn.a\n"
        "dc.ctrl.p1.btn-b       gp0.btn.b\n"
        "dc.ctrl.p1.btn-x       gp0.btn.x\n"
        "dc.ctrl.p1.btn-y       gp0.btn.y\n"
        "dc.ctrl.p1.btn-start   gp0.btn.start\n"
        "\n"
        "; the (1) versions of the controls are duplicates so you can have\n"
        "; the same control bound to more than one key on the host machine.\n"
        "; There is no (2), (3), etc but there might be someday in the\n"
        "; future.\n"
        "dc.ctrl.p1.stick-up(1)    kbd.w\n"
        "dc.ctrl.p1.stick-left(1)  kbd.a\n"
        "dc.ctrl.p1.stick-down(1)  kbd.s\n"
        "dc.ctrl.p1.stick-right(1) kbd.d\n"
        "dc.ctrl.p1.trig-l(1)      kbd.q\n"
        "dc.ctrl.p1.trig-r(1)      kbd.e\n"
        "dc.ctrl.p1.dpad-up(1)     kbd.up\n"
        "dc.ctrl.p1.dpad-left(1)   kbd.left\n"
        "dc.ctrl.p1.dpad-down(1)   kbd.down\n"
        "dc.ctrl.p1.dpad-right(1)  kbd.right\n"
        "dc.ctrl.p1.btn-a(1)       kbd.keypad2\n"
        "dc.ctrl.p1.btn-b(1)       kbd.keypad6\n"
        "dc.ctrl.p1.btn-x(1)       kbd.keypad4\n"
        "dc.ctrl.p1.btn-y(1)       kbd.keypad8\n"
        "dc.ctrl.p1.btn-start(1)   kbd.space\n"
        "\n"
        "; player 2 control bindings.  There's also a (1) for redundant key\n"
        "; bindings if you want to use it, but it's not enabled by default.\n"
        "dc.ctrl.p2.dpad-up     gp1.btn.up\n"
        "dc.ctrl.p2.dpad-left   gp1.btn.left\n"
        "dc.ctrl.p2.dpad-down   gp1.btn.down\n"
        "dc.ctrl.p2.dpad-right  gp1.btn.right\n"
        "dc.ctrl.p2.stick-left  gp1.axis.lhor-\n"
        "dc.ctrl.p2.stick-right gp1.axis.lhor+\n"
        "dc.ctrl.p2.stick-up    gp1.axis.lvert-\n"
        "dc.ctrl.p2.stick-down  gp1.axis.lvert+\n"
        "dc.ctrl.p2.trig-l      gp1.axis.l2\n"
        "dc.ctrl.p2.trig-r      gp1.axis.r2\n"
        "dc.ctrl.p2.btn-a       gp1.btn.a\n"
        "dc.ctrl.p2.btn-b       gp1.btn.b\n"
        "dc.ctrl.p2.btn-x       gp1.btn.x\n"
        "dc.ctrl.p2.btn-y       gp1.btn.y\n"
        "dc.ctrl.p2.btn-start   gp1.btn.start\n"
        "\n"
        "; dc.ctrl.p2.stick-up(1)    kbd.w\n"
        "; dc.ctrl.p2.stick-left(1)  kbd.a\n"
        "; dc.ctrl.p2.stick-down(1)  kbd.s\n"
        "; dc.ctrl.p2.stick-right(1) kbd.d\n"
        "; dc.ctrl.p2.trig-l(1)      kbd.q\n"
        "; dc.ctrl.p2.trig-r(1)      kbd.e\n"
        "; dc.ctrl.p2.dpad-up(1)     kbd.up\n"
        "; dc.ctrl.p2.dpad-left(1)   kbd.left\n"
        "; dc.ctrl.p2.dpad-down(1)   kbd.down\n"
        "; dc.ctrl.p2.dpad-right(1)  kbd.right\n"
        "; dc.ctrl.p2.btn-a(1)       kbd.keypad2\n"
        "; dc.ctrl.p2.btn-b(1)       kbd.keypad6\n"
        "; dc.ctrl.p2.btn-x(1)       kbd.keypad4\n"
        "; dc.ctrl.p2.btn-y(1)       kbd.keypad8\n"
        "; dc.ctrl.p2.btn-start(1)   kbd.space\n"
        "\n"
        "; player 3 control bindings.  There's also a (1) for redundant key\n"
        "; bindings if you want to use it, but it's not enabled by default.\n"
        "dc.ctrl.p3.dpad-up     gp2.btn.up\n"
        "dc.ctrl.p3.dpad-left   gp2.btn.left\n"
        "dc.ctrl.p3.dpad-down   gp2.btn.down\n"
        "dc.ctrl.p3.dpad-right  gp2.btn.right\n"
        "dc.ctrl.p3.stick-left  gp2.axis.lhor-\n"
        "dc.ctrl.p3.stick-right gp2.axis.lhor+\n"
        "dc.ctrl.p3.stick-up    gp2.axis.lvert-\n"
        "dc.ctrl.p3.stick-down  gp2.axis.lvert+\n"
        "dc.ctrl.p3.trig-l      gp2.axis.l2\n"
        "dc.ctrl.p3.trig-r      gp2.axis.r2\n"
        "dc.ctrl.p3.btn-a       gp2.btn.a\n"
        "dc.ctrl.p3.btn-b       gp2.btn.b\n"
        "dc.ctrl.p3.btn-x       gp2.btn.x\n"
        "dc.ctrl.p3.btn-y       gp2.btn.y\n"
        "dc.ctrl.p3.btn-start   gp2.btn.start\n"
        "\n"
        "; dc.ctrl.p3.stick-up(1)    kbd.w\n"
        "; dc.ctrl.p3.stick-left(1)  kbd.a\n"
        "; dc.ctrl.p3.stick-down(1)  kbd.s\n"
        "; dc.ctrl.p3.stick-right(1) kbd.d\n"
        "; dc.ctrl.p3.trig-l(1)      kbd.q\n"
        "; dc.ctrl.p3.trig-r(1)      kbd.e\n"
        "; dc.ctrl.p3.dpad-up(1)     kbd.up\n"
        "; dc.ctrl.p3.dpad-left(1)   kbd.left\n"
        "; dc.ctrl.p3.dpad-down(1)   kbd.down\n"
        "; dc.ctrl.p3.dpad-right(1)  kbd.right\n"
        "; dc.ctrl.p3.btn-a(1)       kbd.keypad2\n"
        "; dc.ctrl.p3.btn-b(1)       kbd.keypad6\n"
        "; dc.ctrl.p3.btn-x(1)       kbd.keypad4\n"
        "; dc.ctrl.p3.btn-y(1)       kbd.keypad8\n"
        "; dc.ctrl.p3.btn-start(1)   kbd.space\n"
        "\n"
        "; player 4 control bindings.  There's also a (1) for redundant key\n"
        "; bindings if you want to use it, but it's not enabled by default.\n"
        "dc.ctrl.p4.dpad-up     gp3.btn.up\n"
        "dc.ctrl.p4.dpad-left   gp3.btn.left\n"
        "dc.ctrl.p4.dpad-down   gp3.btn.down\n"
        "dc.ctrl.p4.dpad-right  gp3.btn.right\n"
        "dc.ctrl.p4.stick-left  gp3.axis.lhor-\n"
        "dc.ctrl.p4.stick-right gp3.axis.lhor+\n"
        "dc.ctrl.p4.stick-up    gp3.axis.lvert-\n"
        "dc.ctrl.p4.stick-down  gp3.axis.lvert+\n"
        "dc.ctrl.p4.trig-l      gp3.axis.l2\n"
        "dc.ctrl.p4.trig-r      gp3.axis.r2\n"
        "dc.ctrl.p4.btn-a       gp3.btn.a\n"
        "dc.ctrl.p4.btn-b       gp3.btn.b\n"
        "dc.ctrl.p4.btn-x       gp3.btn.x\n"
        "dc.ctrl.p4.btn-y       gp3.btn.y\n"
        "dc.ctrl.p4.btn-start   gp3.btn.start\n"
        "\n"
        "; dc.ctrl.p4.stick-up(1)    kbd.w\n"
        "; dc.ctrl.p4.stick-left(1)  kbd.a\n"
        "; dc.ctrl.p4.stick-down(1)  kbd.s\n"
        "; dc.ctrl.p4.stick-right(1) kbd.d\n"
        "; dc.ctrl.p4.trig-l(1)      kbd.q\n"
        "; dc.ctrl.p4.trig-r(1)      kbd.e\n"
        "; dc.ctrl.p4.dpad-up(1)     kbd.up\n"
        "; dc.ctrl.p4.dpad-left(1)   kbd.left\n"
        "; dc.ctrl.p4.dpad-down(1)   kbd.down\n"
        "; dc.ctrl.p4.dpad-right(1)  kbd.right\n"
        "; dc.ctrl.p4.btn-a(1)       kbd.keypad2\n"
        "; dc.ctrl.p4.btn-b(1)       kbd.keypad6\n"
        "; dc.ctrl.p4.btn-x(1)       kbd.keypad4\n"
        "; dc.ctrl.p4.btn-y(1)       kbd.keypad8\n"
        "; dc.ctrl.p4.btn-start(1)   kbd.space\n"
        "\n"
        "; player 1 keyboard bindings.\n"
        "; these only apply if you change\n"
        "; wash.dc.port.0.0 dreamcast_controller\n"
        "; to\n"
        "; wash.dc.port.0.0 dreamcast_keyboard_us\n"
        "; above.  Otherise, they do nothing because you have a controller\n"
        "; plugged in instead of a keyboard.\n"

        "dc.ctrl.p1_1.kbd-us.a kbd.a\n"
        "dc.ctrl.p1_1.kbd-us.b kbd.b\n"
        "dc.ctrl.p1_1.kbd-us.c kbd.c\n"
        "dc.ctrl.p1_1.kbd-us.d kbd.d\n"
        "dc.ctrl.p1_1.kbd-us.e kbd.e\n"
        "dc.ctrl.p1_1.kbd-us.f kbd.f\n"
        "dc.ctrl.p1_1.kbd-us.g kbd.g\n"
        "dc.ctrl.p1_1.kbd-us.h kbd.h\n"
        "dc.ctrl.p1_1.kbd-us.i kbd.i\n"
        "dc.ctrl.p1_1.kbd-us.j kbd.j\n"
        "dc.ctrl.p1_1.kbd-us.k kbd.k\n"
        "dc.ctrl.p1_1.kbd-us.l kbd.l\n"
        "dc.ctrl.p1_1.kbd-us.m kbd.m\n"
        "dc.ctrl.p1_1.kbd-us.n kbd.n\n"
        "dc.ctrl.p1_1.kbd-us.o kbd.o\n"
        "dc.ctrl.p1_1.kbd-us.p kbd.p\n"
        "dc.ctrl.p1_1.kbd-us.q kbd.q\n"
        "dc.ctrl.p1_1.kbd-us.r kbd.r\n"
        "dc.ctrl.p1_1.kbd-us.s kbd.s\n"
        "dc.ctrl.p1_1.kbd-us.t kbd.t\n"
        "dc.ctrl.p1_1.kbd-us.u kbd.u\n"
        "dc.ctrl.p1_1.kbd-us.v kbd.v\n"
        "dc.ctrl.p1_1.kbd-us.w kbd.w\n"
        "dc.ctrl.p1_1.kbd-us.x kbd.x\n"
        "dc.ctrl.p1_1.kbd-us.y kbd.y\n"
        "dc.ctrl.p1_1.kbd-us.z kbd.z\n"
        "dc.ctrl.p1_1.kbd-us.1 kbd.1\n"
        "dc.ctrl.p1_1.kbd-us.2 kbd.2\n"
        "dc.ctrl.p1_1.kbd-us.3 kbd.3\n"
        "dc.ctrl.p1_1.kbd-us.4 kbd.4\n"
        "dc.ctrl.p1_1.kbd-us.5 kbd.5\n"
        "dc.ctrl.p1_1.kbd-us.6 kbd.6\n"
        "dc.ctrl.p1_1.kbd-us.7 kbd.7\n"
        "dc.ctrl.p1_1.kbd-us.8 kbd.8\n"
        "dc.ctrl.p1_1.kbd-us.9 kbd.9\n"
        "dc.ctrl.p1_1.kbd-us.0 kbd.0\n"
        "dc.ctrl.p1_1.kbd-us.enter kbd.enter\n"
        "dc.ctrl.p1_1.kbd-us.escape kbd.escape\n"
        "dc.ctrl.p1_1.kbd-us.backspace kbd.backspace\n"
        "dc.ctrl.p1_1.kbd-us.tab kbd.tab\n"
        "dc.ctrl.p1_1.kbd-us.space kbd.space\n"
        "dc.ctrl.p1_1.kbd-us.minus kbd.minus\n"
        "dc.ctrl.p1_1.kbd-us.equal kbd.equal\n"
        "dc.ctrl.p1_1.kbd-us.leftbrace kbd.leftbrace\n"
        "dc.ctrl.p1_1.kbd-us.rightbrace kbd.rightbrace\n"
        "dc.ctrl.p1_1.kbd-us.backslash kbd.backslash\n"
        "dc.ctrl.p1_1.kbd-us.semicolon kbd.semicolon\n"
        "dc.ctrl.p1_1.kbd-us.singlequote kbd.singlequote\n"
        "dc.ctrl.p1_1.kbd-us.backquote kbd.backquote\n"
        "dc.ctrl.p1_1.kbd-us.comma kbd.comma\n"
        "dc.ctrl.p1_1.kbd-us.dot kbd.dot\n"
        "dc.ctrl.p1_1.kbd-us.slash kbd.slash\n"
        "dc.ctrl.p1_1.kbd-us.capslock kbd.capslock\n"
        "dc.ctrl.p1_1.kbd-us.f1 kbd.f1\n"
        "dc.ctrl.p1_1.kbd-us.f2 kbd.f2\n"
        "dc.ctrl.p1_1.kbd-us.f3 kbd.f3\n"
        "dc.ctrl.p1_1.kbd-us.f4 kbd.f4\n"
        "dc.ctrl.p1_1.kbd-us.f5 kbd.f5\n"
        "dc.ctrl.p1_1.kbd-us.f6 kbd.f6\n"
        "dc.ctrl.p1_1.kbd-us.f7 kbd.f7\n"
        "dc.ctrl.p1_1.kbd-us.f8 kbd.f8\n"
        "dc.ctrl.p1_1.kbd-us.f9 kbd.f9\n"
        "dc.ctrl.p1_1.kbd-us.f10 kbd.f10\n"
        "dc.ctrl.p1_1.kbd-us.f11 kbd.f11\n"
        "dc.ctrl.p1_1.kbd-us.f12 kbd.f12\n"

        "dc.ctrl.p1_1.kbd-us.printscreen kbd.printscreen\n"
        "dc.ctrl.p1_1.kbd-us.scrollock kbd.scrollock\n"
        "dc.ctrl.p1_1.kbd-us.pause kbd.pause\n"
        "dc.ctrl.p1_1.kbd-us.insert kbd.insert\n"
        "dc.ctrl.p1_1.kbd-us.home kbd.home\n"
        "dc.ctrl.p1_1.kbd-us.pageup kbd.pageup\n"
        "dc.ctrl.p1_1.kbd-us.del kbd.del\n"
        "dc.ctrl.p1_1.kbd-us.end kbd.end\n"
        "dc.ctrl.p1_1.kbd-us.pagedown kbd.pagedown\n"
        "dc.ctrl.p1_1.kbd-us.right kbd.right\n"
        "dc.ctrl.p1_1.kbd-us.left kbd.left\n"
        "dc.ctrl.p1_1.kbd-us.down kbd.down\n"
        "dc.ctrl.p1_1.kbd-us.up kbd.up\n"
        "dc.ctrl.p1_1.kbd-us.numlock kbd.numlock\n"

        "dc.ctrl.p1_1.kbd-us.keypadslash kbd.keypadslash\n"
        "dc.ctrl.p1_1.kbd-us.keypadasterisk kbd.keypadasterisk\n"
        "dc.ctrl.p1_1.kbd-us.keypadminus kbd.keypadminus\n"
        "dc.ctrl.p1_1.kbd-us.keypadplus kbd.keypadplus\n"
        "dc.ctrl.p1_1.kbd-us.keypadenter kbd.keypadenter\n"
        "dc.ctrl.p1_1.kbd-us.keypad1 kbd.keypad1\n"
        "dc.ctrl.p1_1.kbd-us.keypad2 kbd.keypad2\n"
        "dc.ctrl.p1_1.kbd-us.keypad3 kbd.keypad3\n"
        "dc.ctrl.p1_1.kbd-us.keypad4 kbd.keypad4\n"
        "dc.ctrl.p1_1.kbd-us.keypad5 kbd.keypad5\n"
        "dc.ctrl.p1_1.kbd-us.keypad6 kbd.keypad6\n"
        "dc.ctrl.p1_1.kbd-us.keypad7 kbd.keypad7\n"
        "dc.ctrl.p1_1.kbd-us.keypad8 kbd.keypad8\n"
        "dc.ctrl.p1_1.kbd-us.keypad9 kbd.keypad9\n"
        "dc.ctrl.p1_1.kbd-us.keypad0 kbd.keypad0\n"
        "dc.ctrl.p1_1.kbd-us.keypaddot kbd.keypaddot\n"
        "dc.ctrl.p1_1.kbd-us.s3 kbd.menu\n"

        "dc.ctrl.p1_1.kbd-us.lctrl kbd.lctrl\n"
        "dc.ctrl.p1_1.kbd-us.lshift kbd.lshift\n"
        "dc.ctrl.p1_1.kbd-us.lalt kbd.lalt\n"
        "dc.ctrl.p1_1.kbd-us.s1 kbd.lsuper\n"
        "dc.ctrl.p1_1.kbd-us.rctrl kbd.rctrl\n"
        "dc.ctrl.p1_1.kbd-us.rshift kbd.rshift\n"
        "dc.ctrl.p1_1.kbd-us.ralt kbd.ralt\n"
        "dc.ctrl.p1_1.kbd-us.s2 kbd.rsuper\n"
        ;

    fputs(cfg_default, cfg_file);
}

void cfg_init(FILE *cfg_file) {
    memset(&cfg_state, 0, sizeof(cfg_state));
    cfg_state.state = CFG_PARSE_PRE_KEY;

    fifo_init(&cfg_state.cfg_nodes);

    printf("Parsing wash.cfg\n");
    for (;;) {
        int ch = fgetc(cfg_file);
        if (ch == EOF)
            break;
        cfg_put_char(ch);
    }
    cfg_put_char('\n'); // in case the last line doesn't end with newline
    fclose(cfg_file);
}

void cfg_cleanup(void) {
    struct fifo_node *curs;

    while ((curs = fifo_pop(&cfg_state.cfg_nodes)) != NULL) {
        struct cfg_node *node = &FIFO_DEREF(curs, struct cfg_node, list_node);
        free(node);
    }
}

void cfg_put_char(char ch) {
    /*
     * special case - a null terminator counts as a newline so that any data
     * which does not end in a newline can be flushed.
     */
    if (ch == '\0')
        ch = '\n';

    /*
     * Very simple preprocessor - replace comments with whitespace and
     * otherwise don't modify the parser state
     */
    if (ch == ';')
        cfg_state.in_comment = true;
    if (cfg_state.in_comment) {
        if (ch == '\n')
            cfg_state.in_comment = false;
        else
            ch = ' ';
    }

    switch (cfg_state.state) {
    case CFG_PARSE_PRE_KEY:
        if (ch == '\n') {
            cfg_handle_newline();
        } else if (!isspace(ch)) {
            cfg_state.state = CFG_PARSE_KEY;
            cfg_state.key_len = 1;
            cfg_state.key[0] = ch;
        }
        break;
    case CFG_PARSE_KEY:
        if (ch == '\n') {
            fprintf(stderr, "*** CFG ERROR INCOMPLETE LINE %u ***\n", cfg_state.line_count);
            cfg_handle_newline();
        } else if (isspace(ch)) {
            cfg_state.state = CFG_PARSE_PRE_VAL;
            cfg_state.key[cfg_state.key_len] = '\0';
        } else if (cfg_state.key_len < CFG_NODE_KEY_LEN - 1) {
            cfg_state.key[cfg_state.key_len++] = ch;
        } else {
            printf("CFG file dropped char from line %u; key length is "
                   "limited to %u characters\n",
                   cfg_state.line_count, CFG_NODE_KEY_LEN - 1);
        }
        break;
    case CFG_PARSE_PRE_VAL:
        if (ch == '\n') {
            fprintf(stderr, "*** CFG ERROR INCOMPLETE LINE %u ***\n", cfg_state.line_count);
            cfg_handle_newline();
        } else if (!isspace(ch)) {
            cfg_state.state = CFG_PARSE_VAL;
            cfg_state.val_len = 1;
            cfg_state.val[0] = ch;
        }
        break;
    case CFG_PARSE_VAL:
        if (ch == '\n') {
            cfg_state.val[cfg_state.val_len] = '\0';
            cfg_add_entry();
            cfg_handle_newline();
        } else if (isspace(ch)) {
            cfg_state.state = CFG_PARSE_POST_VAL;
            cfg_state.val[cfg_state.val_len] = '\0';
        } else if (cfg_state.val_len < CFG_NODE_VAL_LEN - 1) {
            cfg_state.val[cfg_state.val_len++] = ch;
        } else {
            printf("CFG file dropped char from line %u; value length is "
                   "limited to %u characters\n",
                   cfg_state.line_count, CFG_NODE_VAL_LEN - 1);
        }
        break;
    case CFG_PARSE_POST_VAL:
        if (ch == '\n') {
            cfg_add_entry();
            cfg_handle_newline();
        } else if (!isspace(ch)) {
            cfg_state.state = CFG_PARSE_ERROR;
            fprintf(stderr, "*** CFG ERROR INVALID DATA LINE %u ***\n", cfg_state.line_count);
        }
        break;
    default:
    case CFG_PARSE_ERROR:
        if (ch == '\n')
            cfg_handle_newline();
        break;
    }
}

static void cfg_add_entry(void) {
    struct cfg_node *dst_node = NULL;
    struct fifo_node *curs;

    FIFO_FOREACH(cfg_state.cfg_nodes, curs) {
        struct cfg_node *node = &FIFO_DEREF(curs, struct cfg_node, list_node);
        if (strcmp(node->key, cfg_state.key) == 0) {
            dst_node = node;
            break;
        }
    }

    if (dst_node) {
        printf("CFG overwriting existing config key \"%s\" at line %u\n",
                 cfg_state.key, cfg_state.line_count);
    } else {
        printf("CFG allocating new config key \"%s\" at line %u\n",
                 cfg_state.key, cfg_state.line_count);
        dst_node = (struct cfg_node*)malloc(sizeof(struct cfg_node));
        memcpy(dst_node->key, cfg_state.key, sizeof(dst_node->key));
        fifo_push(&cfg_state.cfg_nodes, &dst_node->list_node);
    }

    if (dst_node)
        memcpy(dst_node->val, cfg_state.val, sizeof(dst_node->val));
    else
        fprintf(stderr, "CFG file dropped line %u due to failed node allocation\n", cfg_state.line_count);
}

static void cfg_handle_newline(void) {
    cfg_state.state = CFG_PARSE_PRE_KEY;
    cfg_state.key_len = 0;
    cfg_state.val_len = 0;
    cfg_state.line_count++;
}

char const *cfg_get_node(char const *key) {
    struct fifo_node *curs;

    FIFO_FOREACH(cfg_state.cfg_nodes, curs) {
        struct cfg_node *node = &FIFO_DEREF(curs, struct cfg_node, list_node);
        if (strcmp(node->key, key) == 0)
            return node->val;
    }

    return NULL;
}

static int cfg_parse_bool(char const *valstr, bool *outp) {
    if (strcmp(valstr, "true") == 0 || strcmp(valstr, "1") == 0) {
        *outp = true;
        return 0;
    } else if (strcmp(valstr, "false") == 0 || strcmp(valstr, "0") == 0) {
        *outp = false;
        return 0;
    }
    return -1;
}

int cfg_get_bool(char const *key, bool *outp) {
    char const *nodestr = cfg_get_node(key);
    if (nodestr) {
        int success = cfg_parse_bool(nodestr, outp);
        if (success != 0)
            fprintf(stderr, "error parsing config node \"%s\"\n", key);
        return success;
    }
    return -1;
}

static int cfg_parse_rgb(char const *valstr, int *red, int *green, int *blue) {
    if (strlen(valstr) != 7)
        return -1;

    if (valstr[0] != '#')
        return -1;

    int idx;
    unsigned digits[6];

    for (idx = 0; idx < 6; idx++) {
        char ch = valstr[idx + 1];
        if (ch >= '0' && ch <= '9') {
            digits[idx] = ch - '0';
        } else if (ch >= 'a' && ch <= 'f') {
            digits[idx] = ch - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'F') {
            digits[idx] = ch - 'A' + 10;
        } else {
            fprintf(stderr, "Bad color syntax \"%s\"\n", valstr);
            return -1;
        }
    }

    *red = digits[0] * 16 + digits[1];
    *green = digits[2] * 16 + digits[3];
    *blue = digits[4] * 16 + digits[5];

    return 0;
}

static int cfg_parse_decimal_int(char const *valstr, int *val_out) {
    if (!*valstr)
        return -1; //empty string

    int sign = 1;
    if (valstr[0] == '-') {
        valstr++;
        sign = -1;
    } else if (valstr[0] == '+') {
        // you can prepend positive values with + but it won't do anything.
        valstr++;
    }

    size_t len = strlen(valstr);
    if (len == 0)
        return -1;

    int scale = 1;
    int sum = 0;
    do {
        int digit = valstr[len - 1];
        if (!isdigit(digit))
            return -1;
        digit -= '0';
        sum += scale * digit;
        scale *= 10;
    } while (--len);

    *val_out = sign * sum;
    return 0;
}

int cfg_get_rgb(char const *key, int *red, int *green, int *blue) {
    char const *nodestr = cfg_get_node(key);
    if (nodestr) {
        int success = cfg_parse_rgb(nodestr, red, green, blue);
        if (success != 0)
            fprintf(stderr, "error parsing config node \"%s\"\n", key);
        return success;
    }
    return -1;
}

int cfg_get_int(char const *key, int *val) {
    char const *nodestr = cfg_get_node(key);

    if (nodestr) {
        int success = cfg_parse_decimal_int(nodestr, val);
        if (success != 0)
            fprintf(stderr, "error parsing config node \"%s\"\n", key);
        return success;
    }
    return -1;
}
